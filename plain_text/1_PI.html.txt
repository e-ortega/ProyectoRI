         Este sitio utiliza cookies para anÃ¡lisis y para mostrar contenido y anuncios personalizados. Al continuar navegando por este sitio, aceptas este uso.  MÃ¡s informaciÃ³n                   Developer Network  Developer Network  Developer       Suscripciones a MSDN    Obtener herramientas                           Descargas    Visual Studio    SDK    Software de prueba    Descargas gratuitas    Recursos de Office    Recursos de SharePoint Server 2013    Recursos de SQL Server 2014 Express    Recursos de Windows Server 2012        Programas    Suscripciones    Administradores      Estudiantes    Microsoft Imagine    Socios estudiantes de Microsoft      ISV    Nuevas empresas    Eventos      Comunidad    Magazine    Foros    Blogs    Channel 9      DocumentaciÃ³n    API y referencia    Centros de desarrollo    Ejemplos    Contenido retirado                                    Lo sentimos. El contenido solicitado se ha quitado. SerÃ¡ redirigido automÃ¡ticamente en 1 segundo.       Visual C++  Lenguaje C++ y bibliotecas estÃ¡ndar   AquÃ­ estÃ¡ otra vez C++       AquÃ­ estÃ¡ otra vez C++  Punteros inteligentes      Punteros inteligentes      Punteros inteligentes                   Compatibilidad con las caracterÃ­sticas de C++11/14/17    Sistema de tipos de C++    InicializaciÃ³n uniforme y constructores de delegaciÃ³n    DuraciÃ³n de objetos y administraciÃ³n de recursos    Recursos propios de los objetos (RAII)    Punteros inteligentes    CÃ³mo: Crear y usar instancias de unique_ptr    CÃ³mo: Crear y usar instancias de shared_ptr    CÃ³mo: Crear y usar instancias de weak_ptr    CÃ³mo: Crear y usar instancias de CComPtr y CComQIPtr    Pimpl para encapsulaciÃ³n en tiempo de compilaciÃ³n    Contenedores    Algoritmos    Formato de cadena y de E/S    Controlar errores y excepciones    Portabilidad en los lÃ­mites de ABI      TOC     Collapse the table of content  Expand the table of content      Esta documentaciÃ³n estÃ¡ archivada y no tiene mantenimiento.          Se recomienda usar Visual Studio 2017   Descargar ahora     Esta documentaciÃ³n estÃ¡ archivada y no tiene mantenimiento.    Punteros inteligentes (C++ moderno)    Visual Studio 2015       Otras versiones         Visual Studio 2013    Visual Studio 2012        Â Para obtener la documentaciÃ³n mÃ¡s reciente de Visual Studio 2017 RC, consulte DocumentaciÃ³n de Visual Studio 2017 RC . En la programaciÃ³n del lenguaje C++ actual, la biblioteca estÃ¡ndar incluye punteros inteligentes , que se utilizan para asegurarse de que los programas estÃ¡n libres de memoria y de pÃ©rdidas de recursos y son seguros ante excepciones. Usos de los punteros inteligentes Los punteros inteligentes se definen en el espacio de nombres std del archivo de encabezado <memory> .  Son cruciales en la expresiÃ³n de programaciÃ³n RAII o Resource Acquisition Is Initialialization .  El objetivo principal de esta expresiÃ³n es asegurarse de que la adquisiciÃ³n de recursos ocurre al mismo tiempo que se inicializa el objeto, de manera que todos los recursos del objeto se creen y se dispongan en una sola lÃ­nea de cÃ³digo.  En la prÃ¡ctica, el principio bÃ¡sico RAII consiste en proporcionar la propiedad de cualquier recurso asignado por montÃ³n (por ejemplo, memoria asignada dinÃ¡micamente o identificadores de objetos del sistema) a un objeto asignado a la pila cuyo destructor contiene cÃ³digo para eliminar o liberar el recurso, ademÃ¡s de cualquier cÃ³digo asociado de limpieza. En la mayorÃ­a de los casos, cuando se inicializa un puntero o un identificador de recursos sin formato para apuntar a un recurso real, el puntero se pasa inmediatamente a un puntero inteligente.  En el lenguaje C++ actual, los punteros sin formato se utilizan Ãºnicamente en pequeÃ±os bloques de cÃ³digo de Ã¡mbito limitado, bucles o funciones auxiliares donde el rendimiento es crucial y no hay ninguna posibilidad de confusiÃ³n sobre la propiedad. En el ejemplo siguiente se compara una declaraciÃ³n de puntero sin formato con una declaraciÃ³n de puntero inteligente.    C++      Copiar      void UseRawPointer()
{ // Using a raw pointer -- not recommended. Song* pSong = new Song(L "Nothing on You" , L "Bruno Mars" ); // Use pSong...  // Don't forget to delete!  delete pSong;   
} void UseSmartPointer()
{ // Declare a smart pointer on stack and pass it the raw pointer. unique_ptr<Song> song2( new Song(L "Nothing on You" , L "Bruno Mars" )); // Use song2... wstring s = song2->duration_; //... } // song2 is deleted automatically here.      Como se muestra en el ejemplo, un puntero inteligente es una plantilla de clase que se declara en la pila y se inicializa con un puntero sin formato que apunta a un objeto asignado por montÃ³n.  Una vez que se inicializa el puntero inteligente, se convierte en propietario del puntero sin formato.  Esto significa que el puntero inteligente es responsable de eliminar la memoria que el puntero sin formato especifica.  El destructor del puntero inteligente contiene la llamada de eliminaciÃ³n y, dado que el puntero inteligente se declara en la pila, su destructor se invoca cuando el puntero inteligente sale del Ã¡mbito, incluso si se produce una excepciÃ³n en alguna parte que se encuentre mÃ¡s arriba en la pila. Para acceder al puntero encapsulado, utilice los conocidos operadores de puntero -> y * , que la clase del puntero inteligente sobrecarga para devolver el puntero sin formato encapsulado. La expresiÃ³n del puntero inteligente de C++ se asemeja a la creaciÃ³n de objetos en lenguajes como C#: se crea el objeto y despuÃ©s se permite al sistema que se ocupe de eliminarlo en el momento correcto.  La diferencia es que ningÃºn recolector de elementos no utilizados independiente se ejecuta en segundo plano; la memoria se administra con las reglas estÃ¡ndar de Ã¡mbito de C++, de modo que el entorno en tiempo de ejecuciÃ³n es mÃ¡s rÃ¡pido y eficaz. Â Importante Cree siempre punteros inteligentes en una lÃ­nea de cÃ³digo independiente, nunca en una lista de parÃ¡metros, para que no se produzca una pÃ©rdida de recursos imperceptible debido a algunas reglas de asignaciÃ³n de la lista de parÃ¡metros. En el ejemplo siguiente se muestra cÃ³mo se puede utilizar un tipo de puntero inteligente unique_ptr de la biblioteca de plantillas estÃ¡ndar para encapsular un puntero a un objeto grande.    C++      Copiar      class LargeObject
{ public : void DoSomething(){}
}; void ProcessLargeObject( const LargeObject& lo){} void SmartPointerDemo()
{ // Create the object and pass it to a smart pointer std::unique_ptr<LargeObject> pLarge( new LargeObject()); //Call a method on the object pLarge->DoSomething(); // Pass a reference to a method. ProcessLargeObject(*pLarge);

} //pLarge is deleted automatically when function block goes out of scope.      En el ejemplo se muestran los pasos bÃ¡sicos siguientes para utilizar punteros inteligentes. Declare el puntero inteligente como variable automÃ¡tica (local). (No utilice la expresiÃ³n new o malloc en el propio puntero inteligente). En el parÃ¡metro de tipo, especifique el tipo al que apunta el puntero encapsulado. Pase un puntero sin formato al objeto new -ed en el constructor de puntero inteligente. (Algunas funciones de utilidad o constructores de puntero inteligente hacen esto por usted.) Utilice los operadores sobrecargados -> y * para tener acceso al objeto. Deje que el puntero inteligente elimine el objeto. Los punteros inteligentes estÃ¡n diseÃ±ados para ser lo mÃ¡s eficaces posible tanto en tÃ©rminos de memoria como de rendimiento.  Por ejemplo, el Ãºnico miembro de datos de unique_ptr es el puntero encapsulado.  Esto significa que unique_ptr tiene exactamente el mismo tamaÃ±o que ese puntero, cuatro u ocho bytes.  El acceso al puntero encapsulado a travÃ©s del puntero inteligente sobrecargado * y los operadores -> no es mucho mÃ¡s lento que el acceso directo a los punteros sin formato. Los punteros inteligentes tienen sus propias funciones miembro, a las que se accede mediante la notaciÃ³n â€œpuntoâ€.  Por ejemplo, algunos punteros inteligentes de STL tienen una funciÃ³n miembro de restablecimiento que libera la propiedad del puntero.  Esto es Ãºtil cuando se quiere liberar la memoria que es propiedad del puntero inteligente antes de que el puntero inteligente salga del Ã¡mbito, tal y como se muestra en el ejemplo siguiente.    C++      Copiar      void SmartPointerDemo2()
{ // Create the object and pass it to a smart pointer std::unique_ptr<LargeObject> pLarge( new LargeObject()); //Call a method on the object pLarge->DoSomething(); // Free the memory before we exit function block. pLarge.reset(); // Do some other work... }     Los punteros inteligentes suelen proporcionar un mecanismo para acceder directamente al puntero sin formato.  Los punteros inteligentes STL tienen una funciÃ³n miembro de get con este propÃ³sito y CComPtr tiene un miembro de clase p pÃºblico.  Si proporciona acceso directo al puntero subyacente, puede utilizar el puntero inteligente para administrar la memoria en el propio cÃ³digo y continuar pasando el puntero sin formato en un cÃ³digo que no admita punteros inteligentes.    C++      Copiar      void SmartPointerDemo4()
{ // Create the object and pass it to a smart pointer std::unique_ptr<LargeObject> pLarge( new LargeObject()); //Call a method on the object pLarge->DoSomething(); // Pass raw pointer to a legacy API LegacyLargeObjectFunction(pLarge.get());    
}     Clases de punteros inteligentes En la secciÃ³n siguiente se resumen los distintos tipos de punteros inteligentes disponibles en el entorno de programaciÃ³n de Windows y se describe cuÃ¡ndo utilizarlos. Punteros inteligentes de la biblioteca estÃ¡ndar de C++ Utilice estos punteros inteligentes como primera opciÃ³n para encapsular punteros a los objetos estÃ¡ndar de C++ (POCO). unique_ptr Permite exactamente un Ãºnico propietario del puntero subyacente.  Utilice esta opciÃ³n como predeterminada para los objetos POCO, a menos que sepa con certeza que necesita un objeto shared_ptr .  Puede moverse a un nuevo propietario, pero no se puede copiar ni compartir.  Sustituye a auto_ptr , que estÃ¡ desusado.  Comparado con boost::scoped_ptr , unique_ptr es pequeÃ±o y eficaz; el tamaÃ±o es un puntero y admite referencias rvalue de inserciÃ³n y extracciÃ³n rÃ¡pidas en colecciones STL.  Archivo de encabezado: <memory> .  Para obtener mÃ¡s informaciÃ³n, vea CÃ³mo: Crear y usar instancias de unique_ptr y unique_ptr (Clase) . shared_ptr Puntero inteligente con recuento de referencias.  UtilÃ­celo cuando desee asignar un puntero sin formato a varios propietarios, por ejemplo, cuando devuelve una copia de un puntero desde un contenedor pero desea conservar el original.  El puntero sin formato no se elimina hasta que todos los propietarios de shared_ptr han salido del Ã¡mbito o, de lo contrario, han renunciado a la propiedad.  El tamaÃ±o es dos punteros: uno para el objeto y otro para el bloque de control compartido que contiene el recuento de referencias.  Archivo de encabezado: <memory> .  Para obtener mÃ¡s informaciÃ³n, vea CÃ³mo: Crear y usar instancias de shared_ptr y shared_ptr (Clase) . weak_ptr Puntero inteligente de caso especial para usarlo junto con shared_ptr . weak_ptr proporciona acceso a un objeto que pertenece a una o varias instancias de shared_ptr , pero no participa en el recuento de referencias.  UtilÃ­celo cuando desee observar un objeto, pero no quiere que permanezca activo.  Es necesario en algunos casos para interrumpir las referencias circulares entre instancias de shared_ptr .  Archivo de encabezado: <memory> .  Para obtener mÃ¡s informaciÃ³n, vea CÃ³mo: Crear y usar instancias de weak_ptr y weak_ptr (Clase) . Punteros inteligentes para objetos COM (programaciÃ³n clÃ¡sica de Windows) Cuando trabaje con objetos COM, encapsule los punteros de interfaz en un tipo de puntero inteligente adecuado.  Active Template Library (ATL) define varios punteros inteligentes para propÃ³sitos diferentes.  TambiÃ©n puede usar el tipo de puntero inteligente _com_ptr_t , que el compilador utiliza cuando crea clases contenedoras de archivos .tlb.  Es la mejor opciÃ³n si no desea incluir los archivos de encabezado ATL. CComPtr Class Utilice esta opciÃ³n a menos que no puede usar ATL.  Realiza el recuento de referencias mediante los mÃ©todos AddRef y de Release .  Para obtener mÃ¡s informaciÃ³n, vea CÃ³mo: Crear y usar instancias de CComPtr y CComQIPtr . CComQIPtr Class Se parece a CComPtr , pero tambiÃ©n proporciona la sintaxis simplificada para llamar a QueryInterface en objetos COM.  Para obtener mÃ¡s informaciÃ³n, vea CÃ³mo: Crear y usar instancias de CComPtr y CComQIPtr . CComHeapPtr Class Puntero inteligente a objetos que utilizan CoTaskMemFree para liberar memoria. CComGITPtr Class Puntero inteligente para las interfaces que se obtienen de la tabla de interfaz global (GIT). _com_ptr_t (Clase) Se parece a CComQIPtr en funcionalidad, pero no depende de los encabezados ATL. Punteros inteligentes ATL para objetos POCO AdemÃ¡s de punteros inteligentes para los objetos COM, ATL tambiÃ©n define punteros inteligentes y colecciones de punteros inteligentes para objetos estÃ¡ndar de C++.  En la programaciÃ³n clÃ¡sica de Windows, estos tipos son alternativas Ãºtiles a las colecciones STL, especialmente cuando no es necesaria la portabilidad de cÃ³digo o cuando no se quiere mezclar los modelos de programaciÃ³n de STL y ATL. CAutoPtr Class Puntero inteligente que exige una propiedad Ãºnica al transferir la propiedad en la copia.  Puede compararse con la clase std::auto_ptr desusada. CHeapPtr Class Puntero inteligente para objetos asignados mediante la funciÃ³n malloc de C. CAutoVectorPtr Class Puntero inteligente para matrices que se asignan mediante new[] . CAutoPtrArray Class Clase que encapsula una matriz de elementos CAutoPtr . CAutoPtrList Class Clase que encapsula los mÃ©todos para manipular una lista de nodos de CAutoPtr . Vea tambiÃ©n AquÃ­ estÃ¡ otra vez C++ Referencia de lenguaje C++ Biblioteca estÃ¡ndar de C++ informaciÃ³n general: administraciÃ³n de memoria en C++       Mostrar:   Heredado   Protegido         Imprimir   Exportar ( 0 )         Imprimir   Compartir               EN ESTE ARTÃCULO                      Â¿Le resulta Ãºtil esta pÃ¡gina?  SÃ­  No       Â¿Tiene comentarios adicionales?    Caracteres restantes: 1500   Enviar  Pasar por alto         Gracias.  Agradecemos mucho su ayuda.          Centros de desarrollo    Windows    Office    Visual Studio    Microsoft Azure    MÃ¡s...         Recursos de aprendizaje    Microsoft Virtual Academy    Channel 9    MSDN Magazine        Comunidad    Foros    Blogs    Codeplex        Soporte tÃ©cnico    Autoasistencia        Programas    BizSpark (para empresas nuevas)    Microsoft Imagine (for students)    Microsoft en la EducaciÃ³n            EspaÃ±a (EspaÃ±ol)        BoletÃ­n    Privacidad y cookies    TÃ©rminos de uso    Marcas comerciales          Â© 2018 Microsoft       Â© 2018 Microsoft     Third party scripts and code linked to or referenced from this website are licensed to you by the parties that own such code, not by Microsoft.  See ASP.NET Ajax CDN Terms of Use â€“ http://www.asp.net/ajaxlibrary/CDN.ashx.      