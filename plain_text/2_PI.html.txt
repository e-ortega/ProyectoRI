         Puntero inteligente   De Wikipedia, la enciclopedia libre    Ir a la navegaciÃ³n  Ir a la bÃºsqueda  En programaciÃ³n , un puntero inteligente (o smart pointer) es un tipo abstracto de datos que simula el comportamiento de un puntero corriente pero aÃ±adiendo nuevas caracterÃ­sticas adicionales, como recolector de basura automÃ¡tico y comprobador de lÃ­mites. Estas caracterÃ­sticas adicionales tienen como objetivo reducir errores causados por el mal uso de punteros, manteniendo la eficiencia. Los punteros inteligentes suelen llevar un registro de los objetos a los que apunta con el propÃ³sito de gestionar la memoria. El mal uso de los punteros suele ser la mayor fuente de errores: asignaciones constantes, liberaciÃ³n de memoria y la referencia, que debe ser realizada por un programa usando punteros, introduce el riesgo de pÃ©rdidas de memoria. Los punteros inteligentes intentan prevenir las pÃ©rdidas de memoria, liberando automÃ¡ticamente los recursos: cuando un puntero (o el Ãºltimo de una serie de punteros) a un objeto es destruido, porque por ejemplo se sale del Ã¡mbito, el objeto apuntado tambiÃ©n se elimina. Existen varios tipos de punteros inteligentes. Algunos trabajan llevando la cuenta de referencias, otros mediante asignaciÃ³n de un objeto a un Ãºnico puntero. Si el lenguaje soporta recolector de basura automÃ¡tico (por ejemplo, Java ), el uso de los punteros inteligentes es innecesario. En C++ , los punteros inteligentes pueden ser implementados como una "template class" que imita, mediante sobrecarga de operadores, el comportamiento de los punteros tradicionales, pero proporcionando algoritmos de administaciÃ³n de memoria. Los punteros inteligentes pueden facilitar la programaciÃ³n intencional expresando el uso de un puntero en su propio tipo. Por ejemplo, si una funciÃ³n de C++ devuelve un puntero, no hay forma de saber cuando se debe liberar la memoria, cuando se ha terminado con el uso de la informaciÃ³n.  algun_tipo *  function_ambigua ();  // Â¿QuÃ© se deberÃ­a hacer con el resultado?   Tradicionalmente, esto se habrÃ­a resuelto con comentarios, pero esto puede ser propenso a errores. Devolviendo un auto_ptr de C++:  auto_ptr < algun_tipo >  funcion_obvia1 ();   La funciÃ³n hace explÃ­citamente que el "llamador" tenga la propiedad del resultado y, ademÃ¡s, si no se hace nada, no se filtrarÃ¡ memoria. Del mismo modo, si la intenciÃ³n es devolver un puntero a un objeto gestionado en otros lugares, la funciÃ³n podrÃ­a devolver una referencia:  algun_tipo &  funcion_obvia2 ();     Ãndice   1  Punteros inteligentes en Boost   1.1  Scoped pointer  1.2  Shared pointer    2  Enlaces externos    Punteros inteligentes en Boost [ editar ]  La biblioteca Boost de C++ nos ofrece varios tipos de punteros inteligentes, los mÃ¡s importantes son:  Scoped Pointer: Puntero no copiable  Shared Pointer: Puntero copiable  Scoped pointer [ editar ]  Un scoped pointer es una clase de puntero inteligente que no puede copiarse, por lo que solo puede existir un punto de acceso al objeto que apunta.
Cuando el puntero sale del Ã¡mbito, el objeto se destruye y la memoria se libera. Sintaxis:  boost :: scoped_ptr < MiClase >  MiPuntero  ( new  MiClase ( 1 ));  MiPuntero . reset ( new  MiClase ( 2 ));   Se puede acceder al contenido usando el operador *, acceder a la direcciÃ³n con & y acceder al puntero en bruto con el mÃ©todo get(). Ejemplo:   #include  <iostream>  using  namespace  std ;  #include  <boost/scoped_ptr.hpp>  /*  Vamos a crear una clase que informe de cuÃ¡ndo se crea y cuando se  destruye, y lleve un contador de elementos creados.    */  class  Elemento  {  static  int  counter ;  int  n ;  public :  Elemento () : n ( ++ counter ){  cout  <<  "* Creando Elemento "  <<  n  <<  endl ;  };  void  lanzar ( const  char  *  msg ){  cout  <<  "* Elemento "  <<  n  <<  " says: "  <<  msg  <<  endl ;  };  virtual  ~ Elemento (){  cout  <<  "* So Long, Elemento "  <<  n  <<  endl ;  };  };  int  Elemento :: counter  =  0 ;  int  main ( int  argc ,  char  * argv [])  {  /*  Utilizamos corchetes para abrir un nuevo entorno (scope) Vemos  que al terminar el scope, el scoped pointer se libera  automÃ¡ticamente, mientras que en el caso del puntero clÃ¡sico, si  no liberamos manulmente se producirÃ­a una fuga de memoria.  */  cout  <<  "Inicio del scope"  <<  endl ;  {  boost :: scoped_ptr < Elemento >  miElemento ( new  Elemento ());  miElemento  ->  lanzar ( "Mensaje desde myFun_1" );  Elemento  *  classicPointer  =  new  Elemento ();  classicPointer  ->  lanzar  ( "Mensaje del elemento con puntero clÃ¡sico" );  delete  classicPointer ;  // Necesario borrarlo manualmente!  }  cout  <<  "Fin del scope"  <<  endl ;  /*  Si tenemos un scoped pointer como atributo de una clase, o como  variable suelta, es posible asignarle un valor utilizando el  mÃ©todo reset, que borrarÃ¡ lo que estuviera contenido en el  puntero previamente.  */  boost :: scoped_ptr < string >  ptrCadena ;  ptrCadena . reset ( new  string ( "Hola" ));  /*  Los operadores habituales se conservan. En el caso del *, se  devuelve una referencia &. Para acceder al puntero en bruto se  utiliza el mÃ©todo get(), aunque NO SE RECOMIENDA, ya que hacer  modificaciones o borrar el objeto apuntado a travÃ©s de get()  puede producir errores.  */  cout  <<  "Longitud de cadena: "  <<  ptrCadena  ->  length ()  <<  endl ;  cout  <<  * ptrCadena  <<  endl ;  return  0 ;  }   Shared pointer [ editar ]  Un shared pointer es un tipo de puntero inteligente que guarda un contador de referencias al objeto al que apunta. Cada vez que se hace una copia del puntero, se aumenta el contador. Cuando se destruye uno de los shared pointer, el contador disminuye. Cuando el contador llega a cero, quiere decir que no hay mÃ¡s punteros apuntando al objeto, por lo que este puede destruirse y liberar la memoria que ocupa. Todo esto se hace de forma transparente al usuario. Sintaxis:  boost :: shared_ptr < MiClase >  MiPuntero  ( new  MiClase ( 1 ));  boost :: shared_ptr < MiClase >  OtroPuntero  =  MiPuntero ;  MiPuntero . reset ( new  MiClase ( 2 ));   Ejemplo:   #include  <iostream>  #include  <string>  using  namespace  std ;  int  tabulados ;  #include  <boost/shared_ptr.hpp>  /*  Tenemos dos clases. La clase Mirador tiene un shared pointer a  Observado.  */  string  tab (){  return  string ( tabulados ,  '\t' );  }  struct  Observado {  Observado (){  cout  <<  tab ()  <<  "+ Creando Observado"  <<  endl ;  }  ~ Observado (){  cout  <<  tab ()  <<  "- Borrando Observado"  <<  endl ;  }  };  struct  Mirador {  boost :: shared_ptr < Observado >  fan ;  Mirador (){  cout  <<  tab ()  <<  "+ Creando Mirador"  <<  endl ;  }  ~ Mirador (){  cout  <<  tab ()  <<  "- Borrando Mirador"  <<  endl ;  }  };  /*  La funciÃ³n popular rellena el atributo del Mirador con un shared  pointer a Observado.    */  void  popular ( Mirador  &  m1 ,  Mirador  &  m2 ){  boost :: shared_ptr < Observado >  O ( new  Observado );  m1 . fan  =  O ;  m2 . fan  =  O ;  }  int  main ( int  argc ,  char  * argv [])  {  tabulados  =  0 ;  cout  <<  "-- Inicio"  <<  endl ;  {  tabulados  ++ ;  cout  <<  tab ()  <<  "-- Inicio del primer scope"  <<  endl ;  Mirador  M1 ;  {  tabulados  ++ ;  cout  <<  tab ()  <<  "-- Inicio del segundo scope"  <<  endl ;  Mirador  M2 ;  popular ( M1 ,  M2 );  cout  <<  tab ()  <<  "-- Fin del segundo scope"  <<  endl ;  }  tabulados  -- ;  cout  <<  tab ()  <<  "-- Final del primer scope"  <<  endl ;  }  tabulados -- ;  cout  <<  "-- Fin"  <<  endl ;  return  0 ;  }   Enlaces externos [ editar ]  CapÃ­tulo de muestra " Smart Pointers " del libro Modern C++ Design: Generic Programming and Design Patterns Applied por Andrei Alexandrescu , Addison-Wesley, 2001.  CÃ³digo de ejemplo " countptr.hpp " del libro The C++ Standard Library - A Tutorial and Reference por Nicolai M. Josuttis  ArtÃ­culo " Smart Pointers in Boost " [1]  ArtÃ­culo " The New C++: Smart(er) Pointers " por Herb Sutter  " Smart Pointers - What, Why, Which? " por Yonat Sharon  " Smart Pointers Overview " por John M. Dlugosz  YASPER library otra implementaciÃ³n de punteros inteligentes en C++  Smart Pointers en Delphi       Obtenido de Â« https://es.wikipedia.org/w/index.php?title=Puntero_inteligente&oldid=108410569 Â»  CategorÃ­as : ProgramaciÃ³n Tipos de datos      MenÃº de navegaciÃ³n    Herramientas personales   No has accedido DiscusiÃ³n Contribuciones Crear una cuenta Acceder      Espacios de nombres   ArtÃ­culo DiscusiÃ³n       Variantes           Vistas   Leer Editar Ver historial      MÃ¡s         Buscar              NavegaciÃ³n    Portada Portal de la comunidad Actualidad Cambios recientes PÃ¡ginas nuevas PÃ¡gina aleatoria Ayuda Donaciones Notificar un error      Imprimir/exportar    Crear un libro Descargar como PDF VersiÃ³n para imprimir      Herramientas    Lo que enlaza aquÃ­ Cambios en enlazadas Subir archivo PÃ¡ginas especiales Enlace permanente InformaciÃ³n de la pÃ¡gina Elemento de Wikidata Citar esta pÃ¡gina      En otros idiomas    Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ÄŒeÅ¡tina Deutsch English FranÃ§ais Õ€Õ¡ÕµÕ¥Ö€Õ¥Õ¶ Italiano Polski PortuguÃªs Ð ÑƒÑÑÐºÐ¸Ð¹ Ð£ÐºÑ€Ð°Ñ—Ð½ÑÑŒÐºÐ° ä¸­æ–‡   Editar enlaces        Esta pÃ¡gina se editÃ³ por Ãºltima vez el 3 jun 2018 a las 10:36.  El texto estÃ¡ disponible bajo la Licencia Creative Commons AtribuciÃ³n Compartir IgualÂ 3.0 ;
pueden aplicarse clÃ¡usulas adicionales. Al usar este sitio, usted acepta nuestros tÃ©rminos de uso y nuestra polÃ­tica de privacidad . Wikipedia® es una marca registrada de la FundaciÃ³n Wikimedia, Inc. , una organizaciÃ³n sin Ã¡nimo de lucro.    PolÃ­tica de privacidad  Acerca de Wikipedia  LimitaciÃ³n de responsabilidad  Desarrolladores  DeclaraciÃ³n de cookies  VersiÃ³n para mÃ³viles              