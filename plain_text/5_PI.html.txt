                                                             C++ -> Fundamentos de ProgramaciÃ³n     TÃ©cnicas modernas y aplicaciones actuales del lenguaje                      C++ Fundamentos de ProgramaciÃ³n                                                                                              Punteros inteligentes (II)      SemÃ¡ntica de propiedad exclusiva (primera parte)   La plantilla de clase std::unique_ptr<> implementa una semÃ¡ntica de propiedad exclusiva del objeto referenciado. Concretamente, un objeto u de tipo std::unique_ptr<T> almacena un puntero miembro a un segundo objeto de tipo T o derivado, sobre el que se sigue una determinada polÃ­tica de destrucciÃ³n (configurable por el usuario) cuando u es destruido. La semÃ¡ntica de propiedad exclusiva implica que el puntero inteligente u no pueda copiarse, pues de poder hacerlo acabarÃ­amos con dos referencias al mismo objeto. Existe, sin embargo, un mecanismo de transferencia de la propiedad que analizaremos en este post .     El estÃ¡ndar del lenguaje define la siguiente plantilla biparamÃ©trica para objetos simples (no-matriciales):   namespace std {  template<typename T, class D = default_delete<T>> class  unique_ptr ;  }    El segundo parÃ¡metro determina la polÃ­tica de destrucciÃ³n a seguir con el objeto referenciado al finalizar el tiempo de vida del puntero inteligente. La polÃ­tica adoptada por defecto, implementada por la clase std::default_delete<T> , invoca al operador delete sobre el puntero miembro.   namespace std {  template<typename T>
   struct default_delete {
      default_delete() noexcept = default; template < typename U> default_delete( default_delete<U> const &) noexcept { } void operator()(T* p) const { // if T is an incomplete type, the program is ill-formed static_assert(sizeof(T) > 0,"cannot delete pointer to incomplete type"); delete p;
      }
   };  }    De ser necesario el uso explÃ­cito de punteros, la plantilla std::unique_ptr<> se considera la opciÃ³n por defecto para la asignaciÃ³n dinÃ¡mica de memoria de forma segura ante excepciones. A modo de ejemplo, consideremos el cÃ³digo siguiente:   #include <cassert>
#include <memory>
#include <utility>  class Complex {
   double re_,
          im_;
public:
   Complex(double const& re = 0.0, double const& im = 0.0) noexcept
      : re_{re}, im_{im} { }

   double const& real() const noexcept { return re_; } 
   double&       real()       noexcept { return re_; }
   double const& imag() const noexcept { return im_; } 
   double&       imag()       noexcept { return im_; }
};  int main()
{
   std::unique_ptr<Complex> u{new Complex{3.0,4.0}}; // (1) Complex c = *u; // (2) u->real() = 2.0; // (3)  // don't do this: auto v = u; (4) error auto v = std::move(u); // (5) assert(u == nullptr); // (6) ok, execution continues v->imag() = 7.0; // (7)  // don't do this: u->imag() = 1.0;   (8) undefined behavior } // (9)   En (1) se inicializa una variable automÃ¡tica de tipo std::unique_ptr<Complex> , que almacena como dato miembro un puntero a un objeto de tipo Complex (de parte real 3.0 e imaginaria 4.0) almacenado dinÃ¡micamente. Las operaciones de observaciÃ³n propias de los punteros ordinarios se encuentran habilitadas para std::unique_ptr<> gracias a la sobrecarga de operadores. AsÃ­, en (2) , el operador de indirecciÃ³n ( * ) permite acceder al objeto referenciado por u y realizar una copia del mismo en una nueva variable automÃ¡tica c de tipo Complex . En (3) , se invoca a la funciÃ³n miembro real() a travÃ©s del operador de desreferencia ( -> ) para asignar un nuevo valor a la parte real del nÃºmero complejo referenciado por u .  Con el fin de dar efecto a la semÃ¡ntica de propiedad exclusiva, std::unique_ptr<> posee un constructor copia y un operador de asignaciÃ³n copia declarados delete , por lo que tales operaciones se encuentran deshabilitadas. De ahÃ­ que se produzca un error de compilaciÃ³n de intentarse una inicializaciÃ³n como en (4) .   namespace std {  template<typename T, class D = default_delete<T> >
   class unique_ptr {
   public: // unique_ptr is neither CopyConstructible nor CopyAssignable: unique_ptr(unique_ptr const&) = delete ;
      unique_ptr& operator=(unique_ptr const&) = delete ; // unique_ptr is both MoveConstructible and MoveAssignable: unique_ptr(unique_ptr&&) noexcept;
      unique_ptr& operator=(unique_ptr&&) noexcept; // ... }; }   Sin embargo, la plantilla de clase std::unique_ptr<> implementa la semÃ¡ntica de movimiento, de modo que la propiedad del objeto referenciado puede ser transferida a un nuevo puntero inteligente v de tipo std::unique_ptr<Complex> de manera explÃ­cita como en (5) , sin mÃ¡s que utilizar la funciÃ³n std::move() definida en el fichero de cabecera <utility> . Al hacerlo, el puntero miembro de u es reseteado a nullptr , tal y como se comprueba en (6) . A partir de (5) , pues, el puntero v es el responsable Ãºnico del objeto Complex creado al principio del programa, pudiendo realizar operaciones sobre Ã©l como en (7) . El puntero u , si bien vacÃ­o, sigue disponible para una eventual reasignaciÃ³n. Eso sÃ­, cualquier desreferencia del mismo en dicho estado, como en (8) , darÃ­a lugar a un comportamiento indefinido de acuerdo con el estÃ¡ndar del lenguaje.         En (9) , tanto u como v salen fuera de Ã¡mbito, invocÃ¡ndose automÃ¡ticamente al operador delete sobre sus punteros miembro. Esta operaciÃ³n no tiene ningÃºn efecto en u , al ser su puntero miembro nulo. En el caso de v , sin embargo, el objeto por Ã©l apuntado es destruido y su memoria liberada.  Se recomienda, con el fin de obtener un cÃ³digo seguro y robusto, evitar el uso explÃ­cito, no encapsulado, de los operadores new / delete . Es por ello que el nuevo estÃ¡ndar del lenguaje, C++14 , proporciona la plantilla de funciÃ³n std::make_unique<> :   namespace std {  template<typename T, typename... Args>
   unique_ptr<T> make_unique (Args&&... args)
   {
      return unique_ptr<T>{new T(forward<Args>(args)...)};
   }  }     Ã‰sta crea un objeto std::unique_ptr<T> para un tipo T no-matricial, pasando los argumentos args al constructor de T . AsÃ­, la lÃ­nea de cÃ³digo (1) en el ejemplo anterior puede ser sustituida por la expresiÃ³n    auto u = std::make_unique<Complex>(3.0,4.0); // note: u is of type std::unique_ptr<Complex>       Publicado por    Daniel GÃ³mez Vergel     en  domingo, marzo 01, 2015                 Enviar por correo electrÃ³nico Escribe un blog Compartir con Twitter Compartir con Facebook Compartir en Pinterest                No hay comentarios:         Publicar un comentario                    Entrada mÃ¡s reciente    Entrada antigua   PÃ¡gina principal     Suscribirse a: Enviar comentarios (Atom)                  Acerca del blog  Este blog estÃ¡ especialmente dirigido a estudiantes y profesores de Ciencias de la ComputaciÃ³n interesados en la gestiÃ³n eficiente de los recursos de sus sistemas mediante tÃ©cnicas modernas de programaciÃ³n en el lenguaje C++.             Buscar en el blog                              ArtÃ­culos publicados        ►   2016  (15)     ►   noviembre  (3)       ►   octubre  (3)       ►   julio  (1)       ►   mayo  (4)       ►   abril  (4)         ▼   2015  (37)     ►   julio  (3)       ►   junio  (1)       ►   mayo  (2)       ►   abril  (4)       ▼   marzo  (3)   Punteros inteligentes (IV)  Punteros inteligentes (III)  Punteros inteligentes (II)        ►   febrero  (4)       ►   enero  (20)                   Entrada destacada   SemÃ¡nticas de copia y movimiento (I)               Sobre el autor      Daniel GÃ³mez Vergel       Soy Licenciado en FÃ­sica por la Universidad de Sevilla (2005) y 
Doctor en FÃ­sica TeÃ³rica por la Universidad Complutense de Madrid 
(2009). Mi interÃ©s por distintas ramas de la FÃ­sica me ha permitido ocupar 
puestos de investigaciÃ³n en Ã¡reas de muy diversa naturaleza (FÃ­sica 
atÃ³mica, caracterizaciÃ³n de materiales, gravedad cuÃ¡ntica) en centros de
 reconocido prestigio durante los Ãºltimos diez aÃ±os, colaborando con 
equipos experimentales y teÃ³ricos tanto en EspaÃ±a (Centro Nacional de 
Aceleradores y Centro Superior de Investigaciones CientÃ­ficas, entre 
otros) como en el extranjero (Universidad de Utrecht y Universidad 
TÃ©cnica de Lisboa). Y ello con la labor docente como referente permanente, pues la he 
considerado siempre como la mejor forma, en base a mis aptitudes, de 
contribuir a la mejora de la sociedad y a la mejor formaciÃ³n de nuestros
 profesionales.  En la actualidad, formo parte del equipo docente del Departamento de Ciencias y TecnologÃ­a de la Universidad Europea (Madrid) e imparto clases magistrales de asignaturas de FÃ­sica, 
MatemÃ¡ticas y ProgramaciÃ³n enfocadas a diversos Grados acadÃ©micos.   Ver todo mi perfil                                                                 Todos los derechos reservados - Daniel GÃ³mez Vergel - 2015-2016. Tema Sencillo. Con la tecnologÃ­a de Blogger .                                 