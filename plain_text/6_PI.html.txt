         Stack Overflow en español      Preguntas    Etiquetas    Usuarios                                   Iniciar sesión  Registrarse      comunidad actual          Stack Overflow en español     ayuda  chat          Stack Overflow Meta en español       tus comunidades     Regístrate o inicia sesión para personalizar tu lista.    más comunidades Stack Exchange   blog de la empresa           Recorrido Comienza aquí para acceder a una breve descripción general del sitio     Centro de Ayuda Respuestas detalladas para cualquier pregunta que puedas tener     Meta Analizar el funcionamiento y las políticas de este sitio     Sobre nosotros Aprende más sobre Stack Overflow, la empresa     Negocios Aprende más sobre cómo contratar desarrolladores o publicitarte con nosotros              Este sitio usa cookies para ofrecer nuestros servicios y para mostrarte anuncios relevantes y ofertas laborales.
Al usar este sitio, reconoces haber leido y entendido nuestra Política de Cookies , Política de Privacidad , y nuestros Términos de Servicio .
El uso de los Productos y Servicios de Stack Overflow, incluyendo la Red de Stack Overflow, está sujeta a estas políticas y términos.           Ayúdanos a construir una comunidad amable y colaborativa. Conoce nuestro nuevo Código de conducta .            Sobre el uso de punteros inteligentes   Formular una pregunta            voto a favor  2  votar en contra  favorito       Supongamos que se tiene el hipotÃ©tico caso donde se utilizan punteros para todo tipo de variable. MÃ¡s exactamente, tenemos el siguiente procedimiento para leer los elementos de un arreglo unidimensional:  void leer_arreglo(int *&v)
{
    int *i = new int;
    for (*i = 0; *i < dim_v; (*i)++)
    {
        cout << "Elemento " << *i + 1 << ": ";
        cin >> v[*i];
    }
    delete i;       
}  Como se puede apreciar, incluso la variable i , que solo se utiliza para recorrer los elementos del arreglo, es declarada como un puntero a int , y como tal, al final del procedimiento se debe liberar la memoria manualmente.  Â¿CuÃ¡l serÃ­a la soluciÃ³n mÃ¡s razonable para que la variable i permanezca dentro del Ã¡mbito del bucle for y al mismo tiempo se evite liberar manualmente la memoria asignada para dicho puntero?  Mi primer intento fue el que se tiene a continuaciÃ³n:  void leer_vector(int *&v)
{
    for (int *i = new int(0); *i < dim_v; (*i)++)
    {
        cout << "Elemento " << *i + 1 << ": ";
        cin >> v[*i];
    }
    delete i;       
}  El problema es que se genera un error al momento de llegar a la instrucciÃ³n delete i; pues dicha variable ya no existe fuera del Ã¡mbito del for .  DespuÃ©s se me ocurriÃ³ lo siguiente:  void leer_vector(int *&v)
{
    for (int *i = new int(0); *i < dim_v; (*i)++)
    {
        cout << "Elemento " << *i + 1 << ": ";
        cin >> v[*i];
        delete i;
    }       
}  No obstante, tengo serias dudas de que lo anterior sea una buena idea porque en cada iteraciÃ³n estoy liberando la memoria asignada.  No sabÃ­a muy bien que hacer hasta que descubrÃ­ a los llamados punteros inteligentes ( smart pointers , gracias Paula_plus_plus) y entonces lleguÃ© al siguiente cÃ³digo:  void leer_vector(int *&v)
{
    for (auto i = make_unique<int>(); *i < dim_v; (*i)++)
    {
        cout << "Elemento " << *i + 1 << ": ";
        cin >> v[*i];
    }       
}  QuÃ© bonito, Â¿verdad?, la variable i estÃ¡ en dentro del Ã¡mbito del for y no tenemos que preocuparnos de liberar manualmente la memoria asignada. Entonces, surge mi pregunta: Â¿es este un uso vÃ¡lido de los punteros inteligentes?  Hago esta pregunta porque a pesar de revisar algunos enlaces de SO donde se analizan en que casos se deben usar este tipo de punteros, todavÃ­a no tengo del todo claro si en mi caso en particular el Ãºltimo fragmento de cÃ³digo que puse sea una soluciÃ³n correcta y aceptable.  Gracias de antemano por sus comentarios y/o respuestas.    c++  punteros  c++11     compartir | mejorar esta pregunta      editada el 15 may. a las 12:32             formulada el 13 may. a las 15:34       Xam   459 2 4 14              1      Está raspando el cierre por Basada en opiniones . No lo voto porque puede ser interesante para otros, pero deberías reformularla. – Trauma  el 13 may. a las 17:17        1      @Trauma si, ahora que lo vuelvo a leer, entiendo que mi pregunta pueda ser cerrada por ese motivo. Trataré de reformularla. – Xam  el 13 may. a las 17:26        añade un comentario |           1 respuesta 1     activas  más antiguas  votos            voto a favor  2  votar en contra  aceptada       Â¿Es este un uso vÃ¡lido de los punteros inteligentes?   Claro: el cÃ³digo compila, se ejecuta y no produce errores en tiempo de ejecuciÃ³n ni fugas de memoria; asÃ­ pues es un uso vÃ¡lido.  Otra cosa es que el cÃ³digo que has mostrado como ejemplo sea un uso inteligente de los punteros inteligentes, que a mi entender: no lo es; por ejemplo:   Â¿CuÃ¡l serÃ­a la soluciÃ³n mÃ¡s razonable para que la variable i permanezca dentro del Ã¡mbito del bucle for y al mismo tiempo se evite liberar la memoria asignada para dicho puntero?   La razÃ³n de ser de los punteros inteligentes es precisamente liberar la memoria asignada a ellos, asÃ­ que si querÃ­as que la memoria asignada no se liberase: un puntero inteligente no deberÃ­a ser tu elecciÃ³n.   Los punteros inteligentes fueron introducidos en el estÃ¡ndar C++11, aunque en C++ ya existÃ­a un intento de estandarizar el modismo RAII 1 sobre punteros 2 antes del estÃ¡ndar de 2011 ese intento era muy limitado y poco flexible asÃ­ que se decidiÃ³ deprecarlo y desarrollar tres tipos de punteros inteligentes:  Puntero Ãºnico ( std::unique_ptr ).  Envuelve a un puntero que conceptualmente tendrÃ¡ un Ãºnico propietario, cuando se deja de usar el puntero o se reasigna, se liberan los recursos que estuviera manejando; es posible mover el puntero entre diferentes Ã¡mbitos:  std::unique_ptr<int> dame_dato() {
    std::unique_ptr<int> result;
    // Obtenemos dato, de una fuente externa, el dato necesita ser borrado
    // cuando se deje de usar.
    int *puntero_crudo = factoria_de_datos();
    // Asignamos el puntero
    result.reset(puntero_crudo);
    // Devolvemos el puntero inteligente
    return result;
}  El std::unique_ptr creado dentro de dame_dato no libera el puntero asignado al salir de Ã¡mbito si no que hace que cambie de propietario, siendo el anterior propietario la funciÃ³n dame_dato y el nuevo propietario el llamador de la misma.  Puntero compartido ( std::shared_ptr ).  Envuelve a un puntero que conceptualmente tendrÃ¡ mÃºltiples propietarios, la cantidad de propietarios del puntero es recordada como un contador atÃ³mico manejado por el propio puntero inteligente; creciendo al ganar un propietario y decreciendo al perderlo. Cuando el contador de propietarios llega a cero, se liberaran los recursos que el puntero estuviera manejando, tambiÃ©n es posible mover el puntero entre diferentes Ã¡mbitos y si en lugar de moverlo se copia se actualizarÃ¡ el contador de propietarios, esto puede ser costoso a nivel de proceso porque manejar dicho contador implica varias comprobaciones de seguridad. El siguiente cÃ³digo:  struct S {};

void propietarios(const std::shared_ptr<S> &sp)
{
    std::cout << "Propietarios de " << sp.get() << ": " << sp.use_count() << '\n';
}

void f(std::shared_ptr<S> sp) { propietarios(sp); }

int main()
{
    auto sp = std::make_shared<S>();
    propietarios(sp); // Referencia: no aumenta propietarios
    f(sp);            // Copia: aumenta propietarios
    propietarios(sp); // Referencia: no aumenta propietarios
    return 0;
}  ProducirÃ­a la siguiente salida:   Propietarios de 0x22ea170: 1
Propietarios de 0x22ea170: 2
Propietarios de 0x22ea170: 1   Puntero dÃ©bil ( std::weak_ptr ).  Envuelve a un puntero del que conceptualmente no serÃ¡ propietario, cualquier uso del puntero requiere bloquearlo lo que devolverÃ¡ un puntero compartido, permite saber si existe el objeto al que apunta mediante la funciÃ³n std::weak_ptr::expired .  Â¿CuÃ¡ndo usar los punteros inteligentes?  Se usarÃ¡ el puntero Ãºnico cuando sepamos que el recurso apuntado tendrÃ¡ un Ãºnico propietario, el puntero compartido serÃ¡ usado cuando el recurso apuntado tenga varios propietarios y el puntero dÃ©bil se usarÃ¡ para reclamar el uso de punteros compartidos sin apropiarse de ellos (mÃ¡s que temporalmente).    Gracias por mencionarlo Trauma.  El std::auto_ptr , deprecado en C++11 y eliminado del estÃ¡ndar en C++17.      compartir | mejorar esta respuesta      editada el 15 may. a las 12:23             respondida el 15 may. a las 10:34       Paula_plus_plus   17.8k 3 22 50                  Cuando me refería a que se evite liberar la memoria asignada, hablaba de evitar usar el operador delete . Se me pasó usar la palabra "manualmente". Acabo de editar la pregunta. – Xam  el 15 may. a las 12:34               Pues yo no lo entendí ;P – Paula_plus_plus  el 15 may. a las 12:35            Más allá de eso, su respuesta está genial. Gracias por la explicación sobre los distintos tipos de punteros inteligentes. – Xam  el 15 may. a las 12:36        añade un comentario |            Tu Respuesta             borrador guardado  borrador descartado             Registrarse o iniciar sesión    Registrarse mediante Google   Registrarse mediante Facebook   Regístrate con email y contraseña        Publicar como invitado       Nombre     Correo electrónico             Publicar como invitado       Nombre     Correo electrónico            descartar  Al dar click en "Publica Tu Respuesta", reconoces que has leido nuestros términos de servicio actualizados, la política de privacidad y la política de cookies , y que el uso continuo de este sitio está sujeto a estas políticas.     ¿No es la respuesta que buscas?                            Examina otras preguntas con la etiqueta c++  punteros  c++11 o formula tu propia pregunta .         formulada    hace 3 meses      vista     71 veces       activo    hace 3 meses          Enlazados     4   Gestión correcta RAII en C++      Relacionados   0 Duda con listas ligadas (punteros) C++ 5 Duda con enteros, punteros, y nullptr 6 Conversión entre punteros inteligentes 0 Error al implementar un puntero a array en C++ 2 Duda al asignar memoria dinámica a una estructura tipo Matriz en C++ 1 Copiado de punteros Matriz 4 Reservar memoria con malloc y avanzar el puntero ¿es válido? 2 Liberar memoria c++ (delete) 2 Dudas sobre arrays de punteros 0 Duda sobre una función      Preguntas populares en la red     Remove old non-indexed levers for gear changing to make "fixed" speed bike?    Is there a decentralized zk-SNARK (zero-knowledge Succinct Non-Interactive ARgument of Knowledge)?    What do the smaller notes in the Treble Clef indicate?    bend text between ellipsoids    How to take second derivative implicitly    Do I intuitively know if someone already used their reaction?    How far did Forrest Gump run?    Without using numbers, get the highest salary you can. But don't exaggerate!    Which Star Trek movie has a scene where there is a "bomb" that creates life?    Why can std:set (with a single colon) compile?    Do I have to declare painkillers when going to the USA?    What focal length of glasses is best for photography?    If everyone in the world disappeared except 35 random people, how long would it take for one of them to realize they're not alone?    How to insert curly bracket in multirow table    How to encourage a child with autism to practice reading?    How is no password more secure than username+password?    Should I clock in if computer started updating?    Please help to identify vintage aircraft    What is wrong with â€œecho $(stuff)â€ or â€œecho `stuff`â€?    If arm is 'arma', why is unarmed 'inermis' and not 'inarmis'?    Gimp vs Photoshop    Why did political parties form in the United States?    Calculate all possible keys for AES 128 encryption to exploit hardware encryption    Is Neil Tyson's claim that the Gregorian calendar is the "most accurate calendar ever devised" true?    más preguntas populares     fuente de preguntas      lang-cpp        Stack Overflow en español   Recorrido  Ayuda  Chat  Contacto  Feedback  Mobile     Empresa   Stack Overflow  Stack Overflow Business  Developer Jobs  Acerca de  Prensa  Legal  Política de privacidad       Stack Exchange Network   Technology  Life / Arts  Culture / Recreation  Science  Other        Stack Overflow  Server Fault  Super User  Web Applications  Ask Ubuntu  Webmasters  Game Development   TeX - LaTeX  Software Engineering  Unix & Linux  Ask Different (Apple)  WordPress Development  Geographic Information Systems  Electrical Engineering   Android Enthusiasts  Information Security  Database Administrators  Drupal Answers  SharePoint  User Experience  Mathematica   Salesforce  ExpressionEngine® Answers  Stack Overflow em Português  Blender  Network Engineering  Cryptography  Code Review   Magento  Software Recommendations  Signal Processing  Emacs  Raspberry Pi  Stack Overflow Ð½Ð° Ñ€ÑƒÑÑÐºÐ¾Ð¼  Programming Puzzles & Code Golf   Stack Overflow en español  Ethereum  Data Science  Arduino  Bitcoin    more (30)        Photography  Science Fiction & Fantasy  Graphic Design  Movies & TV  Music: Practice & Theory  Worldbuilding  Seasoned Advice (cooking)   Home Improvement  Personal Finance & Money  Academia  Law    more (15)        English Language & Usage  Skeptics  Mi Yodeya (Judaism)  Travel  Christianity  English Language Learners  Japanese Language   Arqade (gaming)  Bicycles  Role-playing Games  Anime & Manga  Puzzling  Motor Vehicle Maintenance & Repair    more (33)        MathOverflow  Mathematics  Cross Validated (stats)  Theoretical Computer Science  Physics  Chemistry  Biology   Computer Science  Philosophy    more (10)        Meta Stack Exchange  Stack Apps  API  Data  Area 51        Blog  Facebook  Twitter  LinkedIn   diseño del sitio / logo © 2018 Stack Exchange Inc; contribuciones de usuarios licenciadas bajo cc by-sa 3.0 con atribución requerida . rev 2018.8.27.31416       Stack Overflow en español funciona mejor con JavaScript habilitado.     