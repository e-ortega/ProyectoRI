               Buscar, aprender, hacer  Stack Overrun es un catalogo de preguntas y respuestas sobre programacion en una forma conveniente en su idioma.    Menu   Preguntas  Comentarios      Buscar         stack overrun   ES CN (ç®€ä½“ä¸­æ–‡) DE (Deutsch) FR (FranÃ§ais) HI (à¤¹à¤¿à¤¨à¥à¤¦à¥€) RU (Ð ÑƒÑÑÐºÐ¸Ð¹)      Introducción a los punteros inteligentes en C++     6  446     Tengo una aplicaciÃ³n C++ que hace un uso extenso de los punteros para mantener estructuras de datos bastante complejas. La aplicaciÃ³n realiza simulaciones matemÃ¡ticas en enormes conjuntos de datos (que podrÃ­an tomar varios GB de memoria) y se compila utilizando Visual Studio de Microsoft.  Ahora estoy reelaborando una parte importante de la aplicaciÃ³n. Para reducir errores (punteros colgantes, fugas de memoria, ...) quisiera comenzar a usar punteros inteligentes. Sacrificar la memoria o el rendimiento es aceptable siempre que sea limitado.  En la prÃ¡ctica, la mayorÃ­a de las clases se mantienen en grupos grandes (un grupo por clase) y aunque las clases pueden referirse entre sÃ­, podrÃ­a considerar el grupo como propietario de todas las instancias de esa clase. Sin embargo, si el grupo decide eliminar una instancia, no quiero que ninguna de las otras clases que aÃºn hacen referencia a la instancia eliminada tenga un puntero colgante.  En otra parte guardo una colecciÃ³n de punteros a las instancias que son entregadas por otros mÃ³dulos en la aplicaciÃ³n. En la prÃ¡ctica, los otros mÃ³dulos mantienen la propiedad de la instancia aprobada, pero en algunos casos, los mÃ³dulos no quieren ocuparse de la propiedad y solo quieren pasar la instancia a la colecciÃ³n, diciÃ©ndole "ahora es tuyo, gestiÃ³nalo".  Â¿CuÃ¡l es la mejor manera de comenzar a introducir punteros inteligentes? Simplemente reemplazar punteros [al azar] con punteros inteligentes no parece una forma correcta, y probablemente no ofrece todas las ventajas (o ninguna de ellas) de los punteros inteligentes. Pero, Â¿quÃ© es un mÃ©todo mejor?  Â¿QuÃ© tipos de indicadores inteligentes debo investigar mÃ¡s? A veces uso std :: auto_ptr para la desasignaciÃ³n de la memoria asignada localmente, pero parece que se ha depreciado en C++ 0x. Â¿Es std :: unique_ptr una mejor alternativa? Â¿O deberÃ­a ir directamente a punteros compartidos u otros tipos de punteros inteligentes?  La pregunta Replacing existing raw pointers with smart pointers parece similar, pero en lugar de preguntar quÃ© tan fÃ¡cil es, me pregunto cuÃ¡l serÃ­a el mejor enfoque y quÃ© tipo de punteros inteligentes son los mÃ¡s adecuados.  Gracias de antemano por sus ideas y sugerencias.    c++  architecture  smart-pointers  Fuente Compartir Crear 07 oct. 10  Patrick   2 respuestas  Ordenando:  Activo  Mas antiguo  Votos    1      Estas son las 3 variedades que se encuentran en el nuevo estÃ¡ndar de C++ 11 (unique_ptr reemplaza auto_ptr)  http://www.stroustrup.com/C++11FAQ.html#std-unique_ptr  http://www.stroustrup.com/C++11FAQ.html#std-shared_ptr  http://www.stroustrup.com/C++11FAQ.html#std-weak_ptr  se puede leer el texto para cada puntero y hay una explicaciÃ³n de cuÃ¡ndo usarlo allÃ­. Para la gestiÃ³n de la memoria local unique_ptr es la elecciÃ³n. No es copiable pero se puede mover, asÃ­ que al moverlo, el receptor se apropia de Ã©l.  Shared_ptr se utiliza si desea compartir una instancia de objeto sin que realmente haya nadie que tenga el objeto y asegurarse de que no se borre mientras alguien todavÃ­a tenga una referencia. Una vez que el Ãºltimo usuario de un objeto destruye el contenedor shared_ptr, se eliminarÃ¡ el objeto contenido.  weak_ptr se utiliza junto con shared_ptr. Le permite a uno "bloquear" para ver si el objeto shared_ptr de referencia todavÃ­a existe antes de intentar acceder al objeto interno.   Fuente Compartir Crear 07 oct 10  David    3     Recomiendo usar unique_ptr cuando sea posible (esto puede requerir algÃºn anÃ¡lisis del programa) y shared_ptr cuando esto sea imposible. En caso de duda, utilice un shared_ptr para maximizar la seguridad: al pasar el control a un contenedor, el recuento de referencias simplemente pasarÃ¡ a dos y luego volverÃ¡ a uno y el contenedor eventualmente delete el objeto asociado automÃ¡ticamente. Cuando el rendimiento se convierte en un problema, considere usar boost::intrusive_ptr .   Fuente Compartir Crear 07 oct 10  Fred Foo  0 +1 buenos consejos. Tienes que estar haciendo un * lote * de creación/destrucción de objetos o copia de punteros para ver una diferencia de rendimiento entre `shared_ptr` y` intrusive_ptr`. – Doug  07 oct. 10        Buscar   Preguntas relacionadas  1335 ¿Qué es un puntero inteligente y cuándo debería usar uno? 263 ¿Es la práctica de devolver una variable de referencia de C++, el mal? 34 C++ 11 Semántica del puntero inteligente  Preguntas populares   19 ¿Cómo debo usar el proveedor en Go 1.6? 20 JavaFX conseguir arrastrar la carpeta de destino de colocación && después de la caída se ha hecho 16 Tener un '' Resource.Attribute 'no contiene una definición para' actionBarSize '"error 21 Crear implementación de la clase Java de forma dinámica en función de las dependencias proporcionadas en el tiempo de ejecución 18 Pass en un tipo a una extensión Swift genérico, o, idealmente, infieren que 17 Cómo filtrar un objeto json complejo usando javascript? 28 Angular2 http.post se ejecuta dos veces 23 Uso del identificador no resuelto GGLContext y GAI 26 Diferencia entre char e int al declarar el carácter 19 recibiendo un error parser_all en I cuando se utiliza knitr para convertir un archivo Rmd básica en HTML         UP  Preguntas  Comentarios   2018 stackoverrun.com  Licensed under cc by-sa 3.0 with attribution required .        Contactenos  ×        Mensaje enviado!  Cerrar  Enviar          