        NavegaciÃ³n de palanca      CoreDump.uno     Preguntas  Etiquetas               AquÃ­ podrÃ­a ser tu PUBLICIDAD     Â¿Por quÃ© no deberÃ­a usar referencias a punteros inteligentes?    votos 24    Recuerdo leer en alguna parte que el uso de referencias a punteros inteligentes puede causar daÃ±os en la memoria. Â¿Esto se debe simplemente al uso de la referencia del puntero inteligente despuÃ©s de su destrucciÃ³n? Â¿O el recuento de referencias se estropea?  Gracias por aclararlo       c++  smart-pointers       Publicado el 07/10/2008 a las 04:41  fuente por usuario Superpolock       6 respuestas     votos 14     Asumiendo que estÃ¡s hablando de shared_ptr aquÃ­ ...   Â¿Esto se debe simplemente al uso de la referencia del puntero inteligente despuÃ©s de su destrucciÃ³n?   Esta es una buena respuesta. Es posible que no sepa absolutamente la vida Ãºtil del puntero a la que se refiere su referencia tambiÃ©n.  Para evitar esto, querrÃ¡ ver boost :: weak_ptr. No participa en el recuento de referencias. Cuando necesitas usarlo, te da un shared_ptr que desaparece una vez que hayas terminado con Ã©l. TambiÃ©n le permitirÃ¡ saber cuÃ¡ndo se ha recopilado el puntero al referido.  De la documentaciÃ³n de weak_ptr   La plantilla de la clase weak_ptr almacena una "referencia dÃ©bil" para un objeto que ya estÃ¡ administrado por un shared_ptr. Para acceder al objeto, un weak_ptr se puede convertir a un shared_ptr utilizando el constructor shared_ptr o el bloqueo de funciÃ³n miembro. Cuando el Ãºltimo shared_ptr del objeto desaparece y el objeto se elimina, el intento de obtener un shared_ptr de las instancias weak_ptr que hacen referencia al objeto eliminado fallarÃ¡: el constructor arrojarÃ¡ una excepciÃ³n de tipo boost :: bad_weak_ptr, y weak_ptr: : lock devolverÃ¡ un shared_ptr vacÃ­o.   Tenga en cuenta que el mÃ©todo caducado () tambiÃ©n le indicarÃ¡ si su ptr aÃºn estÃ¡ activo.      Respondida el 07/10/2008 a las 04:44  fuente por usuario Doug T.       AquÃ­ podrÃ­a ser tu PUBLICIDAD      votos 5    Cuando se utilizan punteros inteligentes (o cualquier objeto de gestiÃ³n de asignaciÃ³n) se cuenta con los comportamientos definidos en el constructor / destructor para gestionar refs / derefs / locks / unlocks. Como resultado, esos tipos de objetos deben ser objetos verdaderos para funcionar correctamente. cuando se utilizan referencias a tales objetos (o punteros) se estÃ¡ pasando por alto el mecanismo (y pidiendo un wedgie).      Respondida el 07/10/2008 a las 05:08  fuente por usuario Dan Hewett         votos 3    TodavÃ­a hay muchos casos en los que una referencia a un puntero inteligente es una buena idea. Un ejemplo obvio es el mÃ©todo de asignaciÃ³n de la clase de puntero inteligente, que acepta una referencia a otro puntero inteligente como su parÃ¡metro.  Hacer un mÃ©todo que acepte una referencia de puntero inteligente significa que el parÃ¡metro no incrementa la cuenta de referencia interna del puntero inteligente. Esto puede mejorar el rendimiento, pero probablemente no mucho. AdemÃ¡s, hay muchas cosas que el mÃ©todo no puede hacer con la referencia, o con el puntero inteligente original. Si sabes lo que son estas cosas y las evitas, pasar por referencia funciona muy bien. Por supuesto, el propÃ³sito de los indicadores inteligentes es evitar tener que saber estas cosas.  AdemÃ¡s, si tiene un mÃ©todo que modificarÃ¡ el valor de un parÃ¡metro de puntero inteligente, se requiere pasar como referencia, como ocurre con cualquier otro tipo.      Respondida el 07/10/2008 a las 05:48  fuente por usuario Jeff B         votos 1    La parte "inteligente" de los punteros inteligentes es administrada por los constructores, destructores, operadores de asignaciÃ³n y otras funciones de la clase de puntero inteligente. Al usar una referencia, estÃ¡ eludiendo estas operaciones: no se llamarÃ¡ al constructor cuando se inicialice su referencia, y no se llamarÃ¡ al destructor cuando su referencia quede fuera del alcance.  En esencia, una referencia a un puntero inteligente es un puntero tonto, con todos los riesgos y trampas que este Ãºltimo implica.      Respondida el 07/10/2008 a las 05:49  fuente por usuario JohnMcG         votos 0    Pasando una referencia a un puntero inteligente en una funciÃ³n es perfectamente seguro y es una buena idea. El objeto puede desaparecer pero el puntero inteligente no, va a ser sentado allÃ­ diciendo nulo al menos hasta que se devuelve la funciÃ³n. Es la mejor manera de poner un alias para un puntero inteligente dentro de su alcance. Si utiliza una referencia con un modificador const en lo que se refiere a continuaciÃ³n, usted tiene una referencia de la observaciÃ³n inteligente:  const smart_ptr<T>&  Es interesante y Ãºtil, la const le impide utilizar la referencia decir, anular el puntero inteligente y eliminar el objeto pero no detiene el puntero inteligente original del mismo y anulando su referencia reflejarÃ¡ ese cambio.  Volviendo una referencia a puntero inteligente de una funciÃ³n es pidiendo todo tipo de problemas.      Respondida el 01/10/2013 a las 03:10  fuente por usuario John Morrison         votos 0    Tenemos smartpointers personalizados y siempre tenemos el hÃ¡bito de pasar un 'const refsomething &'  no incrementa ni disminuye el puntero inteligente, y como tal, y mÃ¡s importante aÃºn, se evitan las llamadas a InterLockedIncrement / Decrement, que a su vez evita una valla de memoria y todas las cosas que lo acompaÃ±an: bloqueo de bus, invalidaciÃ³n de cachÃ©, ... .      Respondida el 07/10/2008 a las 07:14  fuente por usuario QBziZ         AquÃ­ podrÃ­a ser tu PUBLICIDAD                  Licensed under cc by-sa 3.0 with attribution required .        