                                                             C++ -> Fundamentos de Programación     Técnicas modernas y aplicaciones actuales del lenguaje                      C++ Fundamentos de Programación                                                                                              Punteros inteligentes (II)      Semántica de propiedad exclusiva (primera parte)   La plantilla de clase std::unique_ptr<> implementa una semántica de propiedad exclusiva del objeto referenciado. Concretamente, un objeto u de tipo std::unique_ptr<T> almacena un puntero miembro a un segundo objeto de tipo T o derivado, sobre el que se sigue una determinada política de destrucción (configurable por el usuario) cuando u es destruido. La semántica de propiedad exclusiva implica que el puntero inteligente u no pueda copiarse, pues de poder hacerlo acabaríamos con dos referencias al mismo objeto. Existe, sin embargo, un mecanismo de transferencia de la propiedad que analizaremos en este post .     El estándar del lenguaje define la siguiente plantilla biparamétrica para objetos simples (no-matriciales):   namespace std {  template<typename T, class D = default_delete<T>> class  unique_ptr ;  }    El segundo parámetro determina la política de destrucción a seguir con el objeto referenciado al finalizar el tiempo de vida del puntero inteligente. La política adoptada por defecto, implementada por la clase std::default_delete<T> , invoca al operador delete sobre el puntero miembro.   namespace std {  template<typename T>
   struct default_delete {
      default_delete() noexcept = default; template < typename U> default_delete( default_delete<U> const &) noexcept { } void operator()(T* p) const { // if T is an incomplete type, the program is ill-formed static_assert(sizeof(T) > 0,"cannot delete pointer to incomplete type"); delete p;
      }
   };  }    De ser necesario el uso explícito de punteros, la plantilla std::unique_ptr<> se considera la opción por defecto para la asignación dinámica de memoria de forma segura ante excepciones. A modo de ejemplo, consideremos el código siguiente:   #include <cassert>
#include <memory>
#include <utility>  class Complex {
   double re_,
          im_;
public:
   Complex(double const& re = 0.0, double const& im = 0.0) noexcept
      : re_{re}, im_{im} { }

   double const& real() const noexcept { return re_; } 
   double&       real()       noexcept { return re_; }
   double const& imag() const noexcept { return im_; } 
   double&       imag()       noexcept { return im_; }
};  int main()
{
   std::unique_ptr<Complex> u{new Complex{3.0,4.0}}; // (1) Complex c = *u; // (2) u->real() = 2.0; // (3)  // don't do this: auto v = u; (4) error auto v = std::move(u); // (5) assert(u == nullptr); // (6) ok, execution continues v->imag() = 7.0; // (7)  // don't do this: u->imag() = 1.0;   (8) undefined behavior } // (9)   En (1) se inicializa una variable automática de tipo std::unique_ptr<Complex> , que almacena como dato miembro un puntero a un objeto de tipo Complex (de parte real 3.0 e imaginaria 4.0) almacenado dinámicamente. Las operaciones de observación propias de los punteros ordinarios se encuentran habilitadas para std::unique_ptr<> gracias a la sobrecarga de operadores. Así, en (2) , el operador de indirección ( * ) permite acceder al objeto referenciado por u y realizar una copia del mismo en una nueva variable automática c de tipo Complex . En (3) , se invoca a la función miembro real() a través del operador de desreferencia ( -> ) para asignar un nuevo valor a la parte real del número complejo referenciado por u .  Con el fin de dar efecto a la semántica de propiedad exclusiva, std::unique_ptr<> posee un constructor copia y un operador de asignación copia declarados delete , por lo que tales operaciones se encuentran deshabilitadas. De ahí que se produzca un error de compilación de intentarse una inicialización como en (4) .   namespace std {  template<typename T, class D = default_delete<T> >
   class unique_ptr {
   public: // unique_ptr is neither CopyConstructible nor CopyAssignable: unique_ptr(unique_ptr const&) = delete ;
      unique_ptr& operator=(unique_ptr const&) = delete ; // unique_ptr is both MoveConstructible and MoveAssignable: unique_ptr(unique_ptr&&) noexcept;
      unique_ptr& operator=(unique_ptr&&) noexcept; // ... }; }   Sin embargo, la plantilla de clase std::unique_ptr<> implementa la semántica de movimiento, de modo que la propiedad del objeto referenciado puede ser transferida a un nuevo puntero inteligente v de tipo std::unique_ptr<Complex> de manera explícita como en (5) , sin más que utilizar la función std::move() definida en el fichero de cabecera <utility> . Al hacerlo, el puntero miembro de u es reseteado a nullptr , tal y como se comprueba en (6) . A partir de (5) , pues, el puntero v es el responsable único del objeto Complex creado al principio del programa, pudiendo realizar operaciones sobre él como en (7) . El puntero u , si bien vacío, sigue disponible para una eventual reasignación. Eso sí, cualquier desreferencia del mismo en dicho estado, como en (8) , daría lugar a un comportamiento indefinido de acuerdo con el estándar del lenguaje.         En (9) , tanto u como v salen fuera de ámbito, invocándose automáticamente al operador delete sobre sus punteros miembro. Esta operación no tiene ningún efecto en u , al ser su puntero miembro nulo. En el caso de v , sin embargo, el objeto por él apuntado es destruido y su memoria liberada.  Se recomienda, con el fin de obtener un código seguro y robusto, evitar el uso explícito, no encapsulado, de los operadores new / delete . Es por ello que el nuevo estándar del lenguaje, C++14 , proporciona la plantilla de función std::make_unique<> :   namespace std {  template<typename T, typename... Args>
   unique_ptr<T> make_unique (Args&&... args)
   {
      return unique_ptr<T>{new T(forward<Args>(args)...)};
   }  }     Ésta crea un objeto std::unique_ptr<T> para un tipo T no-matricial, pasando los argumentos args al constructor de T . Así, la línea de código (1) en el ejemplo anterior puede ser sustituida por la expresión    auto u = std::make_unique<Complex>(3.0,4.0); // note: u is of type std::unique_ptr<Complex>       Publicado por    Daniel Gómez Vergel     en  domingo, marzo 01, 2015                 Enviar por correo electrónico Escribe un blog Compartir con Twitter Compartir con Facebook Compartir en Pinterest                No hay comentarios:         Publicar un comentario                    Entrada más reciente    Entrada antigua   Página principal     Suscribirse a: Enviar comentarios (Atom)                  Acerca del blog  Este blog está especialmente dirigido a estudiantes y profesores de Ciencias de la Computación interesados en la gestión eficiente de los recursos de sus sistemas mediante técnicas modernas de programación en el lenguaje C++.             Buscar en el blog                              Artículos publicados        ►   2016  (15)     ►   noviembre  (3)       ►   octubre  (3)       ►   julio  (1)       ►   mayo  (4)       ►   abril  (4)         ▼   2015  (37)     ►   julio  (3)       ►   junio  (1)       ►   mayo  (2)       ►   abril  (4)       ▼   marzo  (3)   Punteros inteligentes (IV)  Punteros inteligentes (III)  Punteros inteligentes (II)        ►   febrero  (4)       ►   enero  (20)                   Entrada destacada   Semánticas de copia y movimiento (I)               Sobre el autor      Daniel Gómez Vergel       Soy Licenciado en Física por la Universidad de Sevilla (2005) y 
Doctor en Física Teórica por la Universidad Complutense de Madrid 
(2009). Mi interés por distintas ramas de la Física me ha permitido ocupar 
puestos de investigación en áreas de muy diversa naturaleza (Física 
atómica, caracterización de materiales, gravedad cuántica) en centros de
 reconocido prestigio durante los últimos diez años, colaborando con 
equipos experimentales y teóricos tanto en España (Centro Nacional de 
Aceleradores y Centro Superior de Investigaciones Científicas, entre 
otros) como en el extranjero (Universidad de Utrecht y Universidad 
Técnica de Lisboa). Y ello con la labor docente como referente permanente, pues la he 
considerado siempre como la mejor forma, en base a mis aptitudes, de 
contribuir a la mejora de la sociedad y a la mejor formación de nuestros
 profesionales.  En la actualidad, formo parte del equipo docente del Departamento de Ciencias y Tecnología de la Universidad Europea (Madrid) e imparto clases magistrales de asignaturas de Física, 
Matemáticas y Programación enfocadas a diversos Grados académicos.   Ver todo mi perfil                                                                 Todos los derechos reservados - Daniel Gómez Vergel - 2015-2016. Tema Sencillo. Con la tecnología de Blogger .                                 