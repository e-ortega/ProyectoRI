          Stack Overflow en español                                 Iniciar sesión  Registrarse      comunidad actual          Stack Overflow en español     ayuda  chat          Stack Overflow Meta en español       tus comunidades     Regístrate o inicia sesión para personalizar tu lista.    más comunidades Stack Exchange   blog de la empresa           Recorrido Comienza aquí para acceder a una breve descripción general del sitio     Centro de Ayuda Respuestas detalladas para cualquier pregunta que puedas tener     Meta Analizar el funcionamiento y las políticas de este sitio     Sobre nosotros Aprende más sobre Stack Overflow, la empresa     Negocios Aprende más sobre cómo contratar desarrolladores o publicitarte con nosotros                 Al usar este sitio, reconoces haber leido y entendido nuestra Política de Cookies , Política de Privacidad , y nuestros Términos de Servicio .           Ayúdanos a construir una comunidad amable y colaborativa. Conoce nuestro nuevo Código de conducta .            Stack Overflow en español es un sitio de preguntas y respuestas para programadores y profesionales de la informática. Únete a ellos; toma menos de un minuto:  Registrarse    Así es como funciona:          Cualquiera puede formular una pregunta            Cualquiera puede responder             Se vota a favor de las mejores respuestas, y éstas suben a los primeros puestos               Inicio       Preguntas    Etiquetas    Usuarios                Sobre el uso de punteros inteligentes   Formular una pregunta          voto a favor  2  votar en contra  favorito       Supongamos que se tiene el hipotético caso donde se utilizan punteros para todo tipo de variable. Más exactamente, tenemos el siguiente procedimiento para leer los elementos de un arreglo unidimensional:  void leer_arreglo(int *&v)
{
    int *i = new int;
    for (*i = 0; *i < dim_v; (*i)++)
    {
        cout << "Elemento " << *i + 1 << ": ";
        cin >> v[*i];
    }
    delete i;       
}  Como se puede apreciar, incluso la variable i , que solo se utiliza para recorrer los elementos del arreglo, es declarada como un puntero a int , y como tal, al final del procedimiento se debe liberar la memoria manualmente.  ¿Cuál sería la solución más razonable para que la variable i permanezca dentro del ámbito del bucle for y al mismo tiempo se evite liberar manualmente la memoria asignada para dicho puntero?  Mi primer intento fue el que se tiene a continuación:  void leer_vector(int *&v)
{
    for (int *i = new int(0); *i < dim_v; (*i)++)
    {
        cout << "Elemento " << *i + 1 << ": ";
        cin >> v[*i];
    }
    delete i;       
}  El problema es que se genera un error al momento de llegar a la instrucción delete i; pues dicha variable ya no existe fuera del ámbito del for .  Después se me ocurrió lo siguiente:  void leer_vector(int *&v)
{
    for (int *i = new int(0); *i < dim_v; (*i)++)
    {
        cout << "Elemento " << *i + 1 << ": ";
        cin >> v[*i];
        delete i;
    }       
}  No obstante, tengo serias dudas de que lo anterior sea una buena idea porque en cada iteración estoy liberando la memoria asignada.  No sabía muy bien que hacer hasta que descubrí a los llamados punteros inteligentes ( smart pointers , gracias Paula_plus_plus) y entonces llegué al siguiente código:  void leer_vector(int *&v)
{
    for (auto i = make_unique<int>(); *i < dim_v; (*i)++)
    {
        cout << "Elemento " << *i + 1 << ": ";
        cin >> v[*i];
    }       
}  Qué bonito, ¿verdad?, la variable i está en dentro del ámbito del for y no tenemos que preocuparnos de liberar manualmente la memoria asignada. Entonces, surge mi pregunta: ¿es este un uso válido de los punteros inteligentes?  Hago esta pregunta porque a pesar de revisar algunos enlaces de SO donde se analizan en que casos se deben usar este tipo de punteros, todavía no tengo del todo claro si en mi caso en particular el último fragmento de código que puse sea una solución correcta y aceptable.  Gracias de antemano por sus comentarios y/o respuestas.     c++  punteros  c++11       compartir | mejorar esta pregunta      editada el 15 may. a las 12:32             formulada el 13 may. a las 15:34       Xam   480 2 4 14               1      Está raspando el cierre por Basada en opiniones . No lo voto porque puede ser interesante para otros, pero deberías reformularla. – Trauma  el 13 may. a las 17:17        1      @Trauma si, ahora que lo vuelvo a leer, entiendo que mi pregunta pueda ser cerrada por ese motivo. Trataré de reformularla. – Xam  el 13 may. a las 17:26        añade un comentario |           1 respuesta 1     activas  más antiguas  votos            voto a favor  2  votar en contra  aceptada       ¿Es este un uso válido de los punteros inteligentes?   Claro: el código compila, se ejecuta y no produce errores en tiempo de ejecución ni fugas de memoria; así pues es un uso válido.  Otra cosa es que el código que has mostrado como ejemplo sea un uso inteligente de los punteros inteligentes, que a mi entender: no lo es; por ejemplo:   ¿Cuál sería la solución más razonable para que la variable i permanezca dentro del ámbito del bucle for y al mismo tiempo se evite liberar la memoria asignada para dicho puntero?   La razón de ser de los punteros inteligentes es precisamente liberar la memoria asignada a ellos, así que si querías que la memoria asignada no se liberase: un puntero inteligente no debería ser tu elección.   Los punteros inteligentes fueron introducidos en el estándar C++11, aunque en C++ ya existía un intento de estandarizar el modismo RAII 1 sobre punteros 2 antes del estándar de 2011 ese intento era muy limitado y poco flexible así que se decidió deprecarlo y desarrollar tres tipos de punteros inteligentes:  Puntero único ( std::unique_ptr ).  Envuelve a un puntero que conceptualmente tendrá un único propietario, cuando se deja de usar el puntero o se reasigna, se liberan los recursos que estuviera manejando; es posible mover el puntero entre diferentes ámbitos:  std::unique_ptr<int> dame_dato() {
    std::unique_ptr<int> result;
    // Obtenemos dato, de una fuente externa, el dato necesita ser borrado
    // cuando se deje de usar.
    int *puntero_crudo = factoria_de_datos();
    // Asignamos el puntero
    result.reset(puntero_crudo);
    // Devolvemos el puntero inteligente
    return result;
}  El std::unique_ptr creado dentro de dame_dato no libera el puntero asignado al salir de ámbito si no que hace que cambie de propietario, siendo el anterior propietario la función dame_dato y el nuevo propietario el llamador de la misma.  Puntero compartido ( std::shared_ptr ).  Envuelve a un puntero que conceptualmente tendrá múltiples propietarios, la cantidad de propietarios del puntero es recordada como un contador atómico manejado por el propio puntero inteligente; creciendo al ganar un propietario y decreciendo al perderlo. Cuando el contador de propietarios llega a cero, se liberaran los recursos que el puntero estuviera manejando, también es posible mover el puntero entre diferentes ámbitos y si en lugar de moverlo se copia se actualizará el contador de propietarios, esto puede ser costoso a nivel de proceso porque manejar dicho contador implica varias comprobaciones de seguridad. El siguiente código:  struct S {};

void propietarios(const std::shared_ptr<S> &sp)
{
    std::cout << "Propietarios de " << sp.get() << ": " << sp.use_count() << '\n';
}

void f(std::shared_ptr<S> sp) { propietarios(sp); }

int main()
{
    auto sp = std::make_shared<S>();
    propietarios(sp); // Referencia: no aumenta propietarios
    f(sp);            // Copia: aumenta propietarios
    propietarios(sp); // Referencia: no aumenta propietarios
    return 0;
}  Produciría la siguiente salida:   Propietarios de 0x22ea170: 1
Propietarios de 0x22ea170: 2
Propietarios de 0x22ea170: 1   Puntero débil ( std::weak_ptr ).  Envuelve a un puntero del que conceptualmente no será propietario, cualquier uso del puntero requiere bloquearlo lo que devolverá un puntero compartido, permite saber si existe el objeto al que apunta mediante la función std::weak_ptr::expired .  ¿Cuándo usar los punteros inteligentes?  Se usará el puntero único cuando sepamos que el recurso apuntado tendrá un único propietario, el puntero compartido será usado cuando el recurso apuntado tenga varios propietarios y el puntero débil se usará para reclamar el uso de punteros compartidos sin apropiarse de ellos (más que temporalmente).    Gracias por mencionarlo Trauma.  El std::auto_ptr , deprecado en C++11 y eliminado del estándar en C++17.      compartir | mejorar esta respuesta      editada el 15 may. a las 12:23             respondida el 15 may. a las 10:34       Paula_plus_plus   18.9k 3 22 50                  Cuando me refería a que se evite liberar la memoria asignada, hablaba de evitar usar el operador delete . Se me pasó usar la palabra "manualmente". Acabo de editar la pregunta. – Xam  el 15 may. a las 12:34               Pues yo no lo entendí ;P – Paula_plus_plus  el 15 may. a las 12:35            Más allá de eso, su respuesta está genial. Gracias por la explicación sobre los distintos tipos de punteros inteligentes. – Xam  el 15 may. a las 12:36        añade un comentario |            Tu Respuesta                  borrador guardado  borrador descartado             Registrarse o iniciar sesión    Registrarse mediante Google   Registrarse mediante Facebook   Regístrate con email y contraseña        Publicar como invitado       Nombre     Correo electrónico             Publicar como invitado       Nombre     Correo electrónico           Publica Tu Respuesta  Descartar  Al dar click en "Publica Tu Respuesta", reconoces que has leido nuestros términos de servicio actualizados, la política de privacidad y la política de cookies , y que el uso continuo de este sitio está sujeto a estas políticas.     ¿No es la respuesta que buscas?                            Examina otras preguntas con la etiqueta c++  punteros  c++11 o formula tu propia pregunta .         formulada    hace 4 meses      vista     78 veces       activo    hace 4 meses          Enlazados     4   Gestión correcta RAII en C++      Relacionados   5 Duda con enteros, punteros, y nullptr 6 Conversión entre punteros inteligentes 0 Error al implementar un puntero a array en C++ 2 Duda al asignar memoria dinámica a una estructura tipo Matriz en C++ 1 Copiado de punteros Matriz 4 Reservar memoria con malloc y avanzar el puntero ¿es válido? 2 Liberar memoria c++ (delete) 2 Dudas sobre arrays de punteros 0 Duda sobre una función 2 Duda sobre punteros      Preguntas populares en la red     Does following SOLID lead to writing a framework on top of the tech stack?    Energy band plotting    Why does the LIGO observation disprove higher dimensions?    Given immortality can animals become intelligent?    What are some ways to keep the player engaged in an endless game?    Ordering finite groups by sum of order of elements    Does Force damage count as magical if the feature causing it doesn't?    When does LaTex add indentation at the start of a paragraph?    Smoking Motor Drive parts    What is the capitalist answer to rail passenger transportation being non financially profitable?    Coming clean to my girlfriend    How to replicate the below style in InDesign?    Did Michael Collins ask for a fourth gimbal for Christmas? Is there a recording or transcript?    Asking a coworker to discontinue his chivalrous acts towards me?    List rearrangment with joining of strings    How many threes?    Materials in a tidal water world    How do I make a space battle both realistic, with physics in play such as no sound and weird motion, but also very epic and intense still?    Why are legal and moral responsibilities said to be different?    Why does partisanship trump concerns about hypocrisy with voters?    Marine Predator That Uses Sound as a Weapon?    How resistant are barcodes and QR-codes against attempts to change stored data?    Can a collision with a neutron star make a planet via the can-o-snakes method?    Manager wants to completely avoid any overtime work. How can I adapt to this change?    más preguntas populares     fuente de preguntas      lang-cpp        Stack Overflow en español   Recorrido  Ayuda  Chat  Contacto  Feedback  Mobile     Empresa   Stack Overflow  Stack Overflow Business  Developer Jobs  Acerca de  Prensa  Legal  Política de privacidad       Stack Exchange Network   Technology  Life / Arts  Culture / Recreation  Science  Other        Stack Overflow  Server Fault  Super User  Web Applications  Ask Ubuntu  Webmasters  Game Development   TeX - LaTeX  Software Engineering  Unix & Linux  Ask Different (Apple)  WordPress Development  Geographic Information Systems  Electrical Engineering   Android Enthusiasts  Information Security  Database Administrators  Drupal Answers  SharePoint  User Experience  Mathematica   Salesforce  ExpressionEngine® Answers  Stack Overflow em Português  Blender  Network Engineering  Cryptography  Code Review   Magento  Software Recommendations  Signal Processing  Emacs  Raspberry Pi  Stack Overflow на русском  Programming Puzzles & Code Golf   Stack Overflow en español  Ethereum  Data Science  Arduino  Bitcoin    more (30)        Photography  Science Fiction & Fantasy  Graphic Design  Movies & TV  Music: Practice & Theory  Worldbuilding  Seasoned Advice (cooking)   Home Improvement  Personal Finance & Money  Academia  Law    more (15)        English Language & Usage  Skeptics  Mi Yodeya (Judaism)  Travel  Christianity  English Language Learners  Japanese Language   Arqade (gaming)  Bicycles  Role-playing Games  Anime & Manga  Puzzling  Motor Vehicle Maintenance & Repair    more (33)        MathOverflow  Mathematics  Cross Validated (stats)  Theoretical Computer Science  Physics  Chemistry  Biology   Computer Science  Philosophy    more (10)        Meta Stack Exchange  Stack Apps  API  Data  Area 51        Blog  Facebook  Twitter  LinkedIn   diseño del sitio / logo © 2018 Stack Exchange Inc; contribuciones de usuarios licenciadas bajo cc by-sa 3.0 con atribución requerida . rev 2018.9.27.31749        Stack Overflow en español funciona mejor con JavaScript habilitado.     