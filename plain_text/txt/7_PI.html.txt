         CODE  Q&A Resuelto          Questions    Documentation                           [c++] Punteros, punteros inteligentes o punteros compartidos?               Answers   el término "puntero inteligente" incluye punteros compartidos, punteros automáticos, punteros de bloqueo y otros.  querías decir auto puntero (más ambiguamente conocido como "poseer puntero"), no puntero inteligente. Los consejos tontos (T *) nunca son la mejor solución.  Te obligan a hacer una gestión de memoria explícita, que es prolija, propensa a errores y, en ocasiones, casi imposible.  Pero más importante aún, no señalan tu intención. Los punteros automáticos eliminan la punta en el momento de la destrucción.  Para matrices, prefiera encapsulaciones como vector y deque.  Para otros objetos, muy raramente existe la necesidad de almacenarlos en el montón: solo use los locales y la composición de objetos.  Sin embargo, la necesidad de punteros automáticos surge con las funciones que devuelven los punteros del montón, como las fábricas y los retornos polimórficos. Los punteros compartidos eliminan el puntero cuando se destruye el último puntero compartido.  Esto es útil cuando se desea un esquema de almacenamiento abierto y sin complicaciones, donde la vida útil esperada y la propiedad pueden variar ampliamente según la situación.  Debido a la necesidad de mantener un contador (atómico), son un poco más lentos que los punteros automáticos.  Algunos dicen en broma que los indicadores compartidos son para personas que no pueden diseñar sistemas, juzguen por sí mismos. Para una contraparte esencial de punteros compartidos, busque punteros débiles también.       Question    Esta pregunta ya tiene una respuesta aquí:  ¿Qué es un puntero inteligente y cuándo debería usar uno?  14 respuestas  Estoy programando con punteros normales, pero he oído hablar de bibliotecas como Boost que implementan punteros inteligentes.  También he visto que en el motor de renderizado Ogre3D hay un uso profundo de punteros compartidos. ¿Cuál es exactamente la diferencia entre los tres, y debería seguir usando solo un tipo de ellos?                Para evitar fugas de memoria, puede utilizar punteros inteligentes siempre que sea posible.  Básicamente, hay 2 tipos diferentes de punteros inteligentes en C ++ Referencia contada (por ejemplo, boost :: shared_ptr / std :: tr1: shared_ptr) sin referencia contada (por ejemplo, boost :: scoped_ptr / std :: auto_ptr) La diferencia principal es que los punteros inteligentes contados de referencia se pueden copiar (y usar en std :: containers) mientras que scoped_ptr no.  Los punteros contados no de referencia casi no tienen gastos generales ni gastos generales.  El recuento de referencias siempre introduce algún tipo de sobrecarga. (Sugiero evitar auto_ptr, tiene algunos defectos graves si se usa incorrectamente)             Read More                      Share   Twitter   Google+   Facebook         Links        ¿Cuáles son las diferencias entre una variable de puntero y una variable de referencia en C ++?    Punteros inteligentes: ¿O quién te posee bebé?    ¿Qué es un puntero inteligente y cuándo debería usar uno?    ¿Qué implementaciones de C ++ Smart Pointer están disponibles?    C ++ 11 introdujo un modelo de memoria estandarizada.    Qué significa eso?    ¿Y cómo afectará la programación en C ++?    ¿Por qué las líneas de lectura de stdin son mucho más lentas en C ++ que en Python?    Procesamiento de imágenes: mejora de algoritmos para el reconocimiento de 'Coca-Cola Can'    ¿Por qué las bibliotecas y frameworks C ++ nunca usan punteros inteligentes?    ¿Por qué debería usar un puntero en lugar del objeto en sí?          Tags   c++  pointers                     Español     Top           