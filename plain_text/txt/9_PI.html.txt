        Navegación de palanca      CoreDump.uno     Preguntas  Etiquetas               Aquí podría ser tu PUBLICIDAD     ¿Por qué no debería usar referencias a punteros inteligentes?    votos 24    Recuerdo leer en alguna parte que el uso de referencias a punteros inteligentes puede causar daños en la memoria. ¿Esto se debe simplemente al uso de la referencia del puntero inteligente después de su destrucción? ¿O el recuento de referencias se estropea?  Gracias por aclararlo       c++  smart-pointers       Publicado el 07/10/2008 a las 04:41  fuente por usuario Superpolock       6 respuestas     votos 14     Asumiendo que estás hablando de shared_ptr aquí ...   ¿Esto se debe simplemente al uso de la referencia del puntero inteligente después de su destrucción?   Esta es una buena respuesta. Es posible que no sepa absolutamente la vida útil del puntero a la que se refiere su referencia también.  Para evitar esto, querrá ver boost :: weak_ptr. No participa en el recuento de referencias. Cuando necesitas usarlo, te da un shared_ptr que desaparece una vez que hayas terminado con él. También le permitirá saber cuándo se ha recopilado el puntero al referido.  De la documentación de weak_ptr   La plantilla de la clase weak_ptr almacena una "referencia débil" para un objeto que ya está administrado por un shared_ptr. Para acceder al objeto, un weak_ptr se puede convertir a un shared_ptr utilizando el constructor shared_ptr o el bloqueo de función miembro. Cuando el último shared_ptr del objeto desaparece y el objeto se elimina, el intento de obtener un shared_ptr de las instancias weak_ptr que hacen referencia al objeto eliminado fallará: el constructor arrojará una excepción de tipo boost :: bad_weak_ptr, y weak_ptr: : lock devolverá un shared_ptr vacío.   Tenga en cuenta que el método caducado () también le indicará si su ptr aún está activo.      Respondida el 07/10/2008 a las 04:44  fuente por usuario Doug T.       Aquí podría ser tu PUBLICIDAD      votos 5    Cuando se utilizan punteros inteligentes (o cualquier objeto de gestión de asignación) se cuenta con los comportamientos definidos en el constructor / destructor para gestionar refs / derefs / locks / unlocks. Como resultado, esos tipos de objetos deben ser objetos verdaderos para funcionar correctamente. cuando se utilizan referencias a tales objetos (o punteros) se está pasando por alto el mecanismo (y pidiendo un wedgie).      Respondida el 07/10/2008 a las 05:08  fuente por usuario Dan Hewett         votos 3    Todavía hay muchos casos en los que una referencia a un puntero inteligente es una buena idea. Un ejemplo obvio es el método de asignación de la clase de puntero inteligente, que acepta una referencia a otro puntero inteligente como su parámetro.  Hacer un método que acepte una referencia de puntero inteligente significa que el parámetro no incrementa la cuenta de referencia interna del puntero inteligente. Esto puede mejorar el rendimiento, pero probablemente no mucho. Además, hay muchas cosas que el método no puede hacer con la referencia, o con el puntero inteligente original. Si sabes lo que son estas cosas y las evitas, pasar por referencia funciona muy bien. Por supuesto, el propósito de los indicadores inteligentes es evitar tener que saber estas cosas.  Además, si tiene un método que modificará el valor de un parámetro de puntero inteligente, se requiere pasar como referencia, como ocurre con cualquier otro tipo.      Respondida el 07/10/2008 a las 05:48  fuente por usuario Jeff B         votos 1    La parte "inteligente" de los punteros inteligentes es administrada por los constructores, destructores, operadores de asignación y otras funciones de la clase de puntero inteligente. Al usar una referencia, está eludiendo estas operaciones: no se llamará al constructor cuando se inicialice su referencia, y no se llamará al destructor cuando su referencia quede fuera del alcance.  En esencia, una referencia a un puntero inteligente es un puntero tonto, con todos los riesgos y trampas que este último implica.      Respondida el 07/10/2008 a las 05:49  fuente por usuario JohnMcG         votos 0    Pasando una referencia a un puntero inteligente en una función es perfectamente seguro y es una buena idea. El objeto puede desaparecer pero el puntero inteligente no, va a ser sentado allí diciendo nulo al menos hasta que se devuelve la función. Es la mejor manera de poner un alias para un puntero inteligente dentro de su alcance. Si utiliza una referencia con un modificador const en lo que se refiere a continuación, usted tiene una referencia de la observación inteligente:  const smart_ptr<T>&  Es interesante y útil, la const le impide utilizar la referencia decir, anular el puntero inteligente y eliminar el objeto pero no detiene el puntero inteligente original del mismo y anulando su referencia reflejará ese cambio.  Volviendo una referencia a puntero inteligente de una función es pidiendo todo tipo de problemas.      Respondida el 01/10/2013 a las 03:10  fuente por usuario John Morrison         votos 0    Tenemos smartpointers personalizados y siempre tenemos el hábito de pasar un 'const refsomething &'  no incrementa ni disminuye el puntero inteligente, y como tal, y más importante aún, se evitan las llamadas a InterLockedIncrement / Decrement, que a su vez evita una valla de memoria y todas las cosas que lo acompañan: bloqueo de bus, invalidación de caché, ... .      Respondida el 07/10/2008 a las 07:14  fuente por usuario QBziZ           Aquí podría ser tu PUBLICIDAD        Licensed under cc by-sa 3.0 with attribution required .       